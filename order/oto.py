###############################################################################
# -*- coding: utf-8 -*-
# Order: A tool to characterize the local structure of liquid water 
#        by geometric order parameters
# 
# Authors: Pu Du
# 
# Released under the MIT License
###############################################################################


"""Orientational Tetrahedral Order q
==============================================================
"""

from __future__ import print_function, division
import os
import six
from six.moves import range, zip

import numpy as np
from progress.bar import ChargingBar
from .util import pbc, cos_angle


class Orientational(object):
    """orientational tetrahedral order parameter"""

    def __init__(self, trajectory, center, bins=100):
        self.traj = trajectory
        self.center = center
        self.bins = bins
        base = os.path.basename(self.traj.filename)
        self.fprefix = os.path.splitext(base)[0]
        self.raw = []
    
    def four_neighbors(self, coords, L):
        """compute four nearest water oxygen neighbors"""
        dist = np.zeros([self.traj.n_atoms, self.traj.n_atoms], dtype=np.float)
        for i in range(self.traj.n_atoms - 1):
            for j in range(i + 1, self.traj.n_atoms):
                dx, dy, dz = coords[i] - coords[j]

                #periodic boundary conditions
                dx, dy, dz = pbc(dx, dy, dz, L)

                dist_ij = np.sqrt(dx * dx + dy * dy + dz * dz)
                dist[i][j] = dist_ij
                dist[j][i] = dist_ij
        
        my_vector = np.zeros([self.traj.n_atoms, 4, 3], dtype=float)

        for i in range(self.traj.n_atoms):
            my_list = dist[i]
            four_ns = [a[0] for a in sorted(enumerate(my_list), key=lambda x:x[1])][1:5]
            j = 0
            for index in four_ns:
                dx, dy, dz = coords[index] - coords[i]

                #periodic boundary conditions
                dx, dy, dz = pbc(dx, dy, dz, L)

                my_vector[i][j] = [dx, dy, dz]
                j += 1
        return my_vector

    def orientational_param(self, freq = 1):
        """compute orientational order parameter"""
        #progress bar
        frames = int(self.traj.n_frames / freq)
        bar = ChargingBar('Processing', max=frames, 
        suffix='%(percent).1f%% - %(eta)ds')
        
        for i in range(0, self.traj.n_frames, freq):
            foo = self.four_neighbors(self.traj.coords[i], self.traj.box_size[i])
            for j in range(self.traj.n_atoms):
                if self.traj.atom_names[i][j] == self.center:
                    q = 0.0
                    for k in range(3):
                        for l in range(k + 1, 4):
                            cos_phi = cos_angle(foo[j][k], foo[j][l])
                            q += (cos_phi + 1 / 3) ** 2
                    q = 1 - 3 / 8 * q
                    self.raw.append(q)
            bar.next()
        bar.finish()

    def out_put(self, taskname='OTO', param_name='Q'):
        """output raw data and distribution"""
        raw_data = self.fprefix + '_' + taskname + '_raw.dat'
        with open(raw_data, 'w') as f:
            f.write('#' + taskname + ' generated by Order: A Python Tool\n')
            f.write('#raw data\n')
            for i in self.raw:
                f.write(str(i)+'\n')
        
        if param_name is 'Q':
            his, param = np.histogram(self.raw, bins = self.bins, range=(0,1))
        
        if param_name is 'Sk':
            his, param = np.histogram(self.raw, bins = self.bins, range=(0,1))        
        
        if param_name is 'Eta':       
            his, param = np.histogram(self.raw, bins = self.bins, range=(1,4))
        
        distribution = self.fprefix + '_' + taskname + '.dat'
        with open(distribution, 'w') as f:
            f.write('#' + taskname + ' generated by Order: A Python Tool\n')
            f.write('#' + param_name + '  count\n')
            for q, c in zip(param[1:], his):
                f.write('{:.3f}\t{:d}\n'.format(q, c))